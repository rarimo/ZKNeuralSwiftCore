// The Swift Programming Language
// https://docs.swift.org/swift-book

import Foundation
import ZkNeuralRustCoreLib

/// Image preprocessing options.
public enum ImagePreprocessingOptions {
    /// No preprocessing is applied.
    case None
    /// Preprocessing for face recognition.
    case FaceRecognition

    func toC() -> ImagePreprocessing {
        switch self {
        case .FaceRecognition:
            ZkNeuralRustCoreLib.FaceRecognition
        case .None:
            ZkNeuralRustCoreLib.None
        }
    }
}

/// Callback type for generating proof.
public enum ZKNeuralProvingTypeOptions {
    /// Groth16 proving backend
    case Groth
    /// UltraGroth16 proving backend
    case UltraGroth

    func toC() -> ZKNeuralProvingType {
        switch self {
        case .Groth:
            ZkNeuralRustCoreLib.Groth
        case .UltraGroth:
            ZkNeuralRustCoreLib.UltraGroth
        }
    }
}

/// Configuration used to initialize `ZKNeuralCore`.
public struct ZKNeuralCoreConfiguration {
    public let generateWitnessCallback: GenerateWitnessCallback
    public let generateProofCallback: GenerateProofCallback
    public let provingType: ZKNeuralProvingTypeOptions
}

/// A class that provides functionality to generate zero-knowledge proofs.
public class ZKNeuralCore {
    private let configuration: ZKNeuralCoreConfiguration
    private let innerCore: OpaquePointer!

    /// Initializes a new instance of `ZKNeuralCore` with the provided configuration.
    ///
    /// - Parameters:
    ///   - configuration: An instance of `ZKNeuralCoreConfiguration` containing the callbacks for generating witness and proof.
    public init(
        configuration: ZKNeuralCoreConfiguration
    ) {
        self.configuration = configuration
        self.innerCore = rs_zkneural_new()

        rs_zkneural_set_generate_witness_callback(innerCore, configuration.generateWitnessCallback)
        rs_zkneural_set_generate_proof_callback(innerCore, configuration.generateProofCallback)
        rs_zkneural_set_proving_type(innerCore, configuration.provingType.toC())
    }

    /// Generates a zero-knowledge proof based on the provided input JSON, circuit, and zkey.
    ///
    /// - Parameters:
    ///   - inputJson: The inputs for circuit in JSON.
    ///   - circuit: Circuit data generated by circom compiler.
    ///   - zkey: The zkey used for generating the proof.
    ///
    /// - Returns: Zk Proof serialized in JSON
    public func generateZkProof(
        _ inputJson: Data,
        _ circuit: Data,
        _ zkey: Data
    ) throws -> Data {
        let wtns = try withRustResult {
            rs_zkneural_generate_witness(
                innerCore,
                (circuit as NSData).bytes,
                .init(circuit.count),
                (inputJson as NSData).bytes,
                .init(circuit.count)
            )
        }

        return try withRustResult {
            rs_zkneural_generate_proof(
                innerCore,
                (zkey as NSData).bytes,
                .init(zkey.count),
                (wtns as NSData).bytes,
                .init(wtns.count)
            )
        }
    }

    deinit {
        rs_zkneural_free(innerCore)
    }
}

/// A class that provides functionality to invoke a neural network model using tensors.
public class TensorInvoker {
    private let invoker: OpaquePointer!

    /// Initializes a new instance of `TensorInvoker` with the provided model data in TFLite format.
    ///
    /// - Parameters:
    ///   - modelData: The model data in TFLite format.
    public init(_ modelData: Data) {
        self.invoker = rs_zkneural_tensor_invoker_new(
            (modelData as NSData).bytes,
            .init(modelData.count)
        )
    }

    /// Invokes the neural network model with the provided image.
    ///
    /// - Parameters:
    ///   - imageData: The image data to be processed by the model.
    ///
    /// - Returns: The output data from the model invocation in JSON Format.
    public func fireImage(_ imageData: Data, options: ImagePreprocessingOptions = .None) throws -> Data {
        try withRustResult {
            rs_zkneural_tensor_invoker_image_fire(
                self.invoker,
                (imageData as NSData).bytes,
                .init(imageData.count),
                options.toC()
            )
        }
    }

    /// Generates circuit inputs using the provided neural network.
    ///
    /// - Parameters:
    ///  - address: The address of the neural network.
    ///  - threshold: The threshold value for the neural network.
    ///  - nonce: The nonce value for the neural network.
    ///  - ultraGroth: A boolean indicating whether to use the UltraGroth proving backend.
    ///  - imageData: The image data to be processed by the neural network.
    ///
    ///  - Returns: The generated circuit inputs in JSON format.
    public func drainGenericInputs(
        _ address: String,
        _ threshold: String,
        _ nonce: String,
        _ ultraGroth: Bool,
        _ imageData: Data,
        options: ImagePreprocessingOptions = .None
    ) throws -> Data {
        try withRustResult {
            rs_zkneural_tensor_invoker_drain_generic_inputs(
                self.invoker,
                (imageData as NSData).bytes,
                .init(imageData.count),
                options.toC(),
                stringToMutCChar(address),
                stringToMutCChar(threshold),
                stringToMutCChar(nonce),
                ultraGroth
            )
        }
    }

    deinit {
        rs_zkneural_tensor_invoker_free(invoker)
    }
}

private func stringToMutCChar(_ string: String) -> UnsafeMutablePointer<CChar>? {
    guard let cString = string.cString(using: .utf8) else {
        return nil
    }

    let length = cString.count
    let buffer = UnsafeMutablePointer<CChar>.allocate(capacity: length)
    buffer.initialize(from: cString, count: length)

    return buffer
}
